<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">    
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.0/css/all.css">
    <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
    <link rel="manifest" href="favicon/site.webmanifest">
    <script src="https://code.jquery.com/jquery-3.3.1.js"></script>
    <link rel="stylesheet" href="DocumentationCSS/RecipeProject.css">
    <link href="prism.css" rel="stylesheet" />

    <title>Portfolio</title>
</head>
<body>
    <div class="top-heading">
    <h1>Recipe Project Documentation</h1>
    <br>
    <br>
    <h2>Author</h2>
    <br>
    <p>Ivan Llamas</p>
    <hr>
    <br>
    <h3>Table of Contents</h3>  
    <ul>
    <li><h1><a href="#documentation-part-setup">How To Setup/Install</a></h1></li>
    <br>

    <li><h1><a href="#documentation-part-technologies">Technologies</a></h1></li>
        <ol>
            <li><h2><a href="">Spring Framework + Spring Boot</a></h2></li>
            <li><h2><a href="">Object-to-Relational Mapping + Entities</a></h2></li>
            <li><h2><a href="">Spring Data JPA</a></h2></li>
            <li><h2><a href="">H2 Database</a></h2></li>
            <li><h2><a href="">Maven</a></h2></li>
            
        </ol>
        <br>
    <li><h1><a href="#documentation-part-overview">Structure Overview</a></h1></li>  
    <ol>
            <li><h2><a href="#documentation-part-overview-package">Packages</a></h2></li>
            <ol type="a">
                <li><h4><a href="#documentation-part-overview-package-entity">Entity</a></h3></li>
                <li><h4><a href="#documentation-part-overview-package-repository">Repository</a></h3></li>
                <li><h4><a href="#documentation-part-overview-package-service">Service</a></h3></li>                
                <li><h4><a href="">Data BootStrap</a></h3></li>
                <li><h4><a href="">Command Objects</a></h3></li>
                <li><h4><a href="">Converters</a></h3></li>
                <li><h4><a href="">Controller</a></h3></li>
                <li><h4><a href="">Exceptions</a></h3></li>
            </ol>
            <li><h2><a href="">Resources</a></h2></li>
            <ol type="a">
                <li><h4><a href="">Static</a></h3></li>
                <li><h4><a href="">Templates</a></h3></li> 
                <li><h4><a href="">application.properties</a></h3></li>   
                <li><h4><a href="">data.sql</a></h3></li>
            </ol>   
        </ol>  
            <br>
    <li><h1><a href="">Quick Concept References/Examples</a></h1></li>
            <ol type="a">
                    <li><h4><a href="">Entity Examples + Mappings</a></h3></li>
                    <li><h4><a href="">Object Data Validation</a></h3></li> 
                    <li><h4><a href="">Data Validation in Thymeleaf</a></h3></li>   
                    <li><h4><a href="">Simple Controller method</a></h3></li>
                    <li><h4><a href="">Saving object to Database</a></h3></li>
                    <li><h4><a href="">How to convert Command Object to Entity and back</a></h3></li>
                    <li><h4><a href="">Thymeleaf Form</a></h3></li>
                    <li><h4><a href="">Thymeleaf reading object properties</a></h3></li>
                    <li><h4><a href="">Save image to Database & Suggestion</a></h3></li>
            </ol>

            
 

    </ul>
    <br>
    <hr>   
</div>


    <div class="main-documentation">

        <div id="documentation-part-setup">
                    <h1>How to Install/Setup</h1>
                    
                    <br>    
                    <p>There are a couple ways to run the program, Being that this is essentially a Maven project, you can run it from the command line
                        or import it into any IDE that supports Maven projects like, <a href="https://code.visualstudio.com/" target="_blank">VSCode</a>, <a href="https://netbeans.org/" target="_blank">Netbeans</a>, <a href="https://www.eclipse.org/" target="_blank">Eclipse</a>, <a href="https://www.jetbrains.com/idea/" target="_blank">Intellij</a>, and more.
                    </p>
                    <br>
                    <hr>
                    <br>
        </div>

        <div id="documentation-part-technologies">
            <h1>Technologies</h1>
            
            <br>    
            <p>These are the Technologies used in this Project, The main focus being the <a href="https://spring.io/" target="_blank">Spring Framework + Spring Boot</a></p>
            <br>
            <hr>
            <br>
        </div>

        <div id="documentation-part-overview">
            <h1>Project Structure</h1>
            
            <br>    
            <p>This project uses the Maven project structure of <code>src ↴ </code><pre>
                                                                                <code>main ↴</code>
                                                                                       <code>java</code></pre> In our Java folder, we will find the different packages for our project
            which each serve with a purpose, seperating the components into different groups which spring will be able to read through the various Spring Annotations
        like <code class="language-html">@SpringApplication</code>, <code class="language-html">@Component</code>, <code class="language-html">@Service</code>, and others that create Spring beans into the spring context.</p>
        <br>
        <hr>
        <br>
        </div>

        <div id="documentation-part-overview-package">
            <h1>1. Packages</h1>
            <br>
            <p>Here are the main Java code packages for the Recipe Project. I have organized the packages in way to facilitate reading the code, and give you an idea of how the project is 
                structured, and flowing together to make up the final piece
            </p>
            <br>
            <hr>
            <br>
        </div>

        <div id="documentation-part-overview-package-entity">
                <h2>a. Entity Package</h2>
                <br>
                <p> This project makes heavy emphasis on spring data JPA Entities and annotations associated with it 
                    like <strong>@OneToOne</strong>, <strong>@OneToMany</strong>, <strong>@ManyToOne</strong>, <strong>@ManyToMany</strong> and others. We will break down the use of each annotation in the following code snippets from our entity classes and the Structure of the database.
                </p>
                <br>    
        
        <div class="code-wrapper">       
                <pre><strong>Lets take a look at our Recipe Entity</strong>
<code class="language-java">
@Entity
public class Recipe {
                        
    //PRIMARY KEY
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
                        
    private String description;
    private Integer prepTime;
    private Integer cookTime;
    private Integer servings;
    private String source;
    private String url;
                            
    @Lob
    private String directions;
                            
    //this defines the relationship from recipe class, 
    //the Set of Ingredient objects is going to be in a property called recipe
    @OneToMany(cascade = CascadeType.ALL,mappedBy = "recipe")
    private Set<Ingredient> ingredients = new HashSet<>();
                            
    @Lob
    private Byte[] image;
                            
                            
    //annotation to mark our enum in our database
    @Enumerated(value = EnumType.STRING)
    private Difficulty difficulty; 
                        
    //relationship to Note object
    @OneToOne(cascade = CascadeType.ALL)
    private Notes notes;
                            
                            
    //joining tables for our recipe -> category, and the columns will be from recipe to category as 'recipe_id'
    //and from category to recipe as 'category_id'
    @ManyToMany
    @JoinTable(name = "recipe_category",
    joinColumns = @JoinColumn(name = "recipe_id"), 
        inverseJoinColumns = @JoinColumn(name = "category_id"))
        private Set<Category> categories = new HashSet<>();
                
    //method for adding ingredient to our recipe
    public Recipe addIngredient(Ingredient ingredient){
        ingredient.setRecipe(this);
        this.ingredients.add(ingredient);
      return this;
    }
}</code>You'll notice that this entity has a variety of annotations like @OneToOne, @OneToMany, and @ManyToMany
this is part of <strong>Hibernate ORM</strong>, and each annotation corresponds to a relationship between columns and tables to other
columns and other tables in the database (H2 Embedded Database in this case)
</pre>  
    </div>
    
                <img id="recipe-image"src="https://i.ibb.co/ZcZTzZt/Screen-Shot-2019-04-03-at-7-03-32-PM.png" style="max-width: 800px" alt="" srcset="">
                <hr>
                <br>
                <br>

                <!---------------------------- ONE TO ONE EXPLANATION -------------------------------->
                <h2>@OneToOne</h2>
                <hr>
                <p>This specifies that there is a relationship in the database tables with a Single relationship, in this case, recipe is related to the Notes entity and in the Notes entity it is related back to recipe</p>
        <div class="code-wrapper">       
                        <pre><strong>One To One Example</strong><code class="language-java">
    
    @Entity
    public class Recipe{
                 //One To One relationship to notes
        @OneToOne
        private Notes notes;
    
    }

    @Entity
    public class Notes{
                 //One To One relationship to recipe 
        @OneToOne
        private Recipe recipe;

    }
        </code>Both of these columns in the database know about each other, you can expect Recipe table to have a Notes_Id columns
and the Notes column to have a Recipe_Id column that relate to each other</pre></div>            
<img src="https://i.ibb.co/YyDGMyz/Screen-Shot-2019-04-03-at-7-01-16-PM.png" style="max-width: 600px"alt="" srcset="">
<hr>
<br>
<br>
        <!------------------------- ONE TO MANY/MANY TO ONE EXPLANATION ------------------------------>
        <h2>@OneToMany/@ManyToOne</h2>
        <hr>
        <p>Refers to the relationship between 2 entities, where A might be linked to many elements of B but B is only linked to one element of A example: One area can be the habitat of many readers(OneToMany). 
        but Many readers live in one area. Usually the Variables with @ManyToOne are the 'owning' column in the database, meaning that the table
        Recipe will NOT have a column for ingredients but ingredients will have a column for Recipe</p>
            
        <div class="code-wrapper">       
                <pre><strong>One To Many / Many To One Example</strong><code class="language-java">

public class Recipe{
    
    //One recipe can have many ingredients
    @OneToMany(cascade = CascadeType.ALL,mappedBy = "recipe")
    private Set<Ingredient> ingredients;
}
                            
                        /*********************************/
                            
public class Ingredient{
                            
    //Many Ingredients have one recipe
    @ManyToOne
    private Recipe recipe;
                            
}
</code>If you look at the <a href="#recipe-image">Recipe Table</a> you'll notice that there is no ingredients column, that is because
Ingredient entity is the 'owning column' of the relationship between the two entities, and <strong>Ingredients table</strong> has a <strong>Recipe_ID</strong> column</pre></div>
<img src="https://i.ibb.co/WpKFd8w/Screen-Shot-2019-04-03-at-9-10-50-PM.png" style="max-width: 500px;" alt="" srcset="">
<hr>
<br>
<br>

            <!---------------- MANY TO MANY ANNOTATION EXPLANATION --------------------->
            <h2>@ManyToMany</h2>
            <hr>
            <p>This refers to the relationship where 2 entities, 
                A and B, in which A may contain a parent instance for which there are many children in B and vice versa. for example: think of A as Authors, 
                and B as Books. An Author can write several Books, and a Book can be written by several Authors. In this case, there will be a seperate table 
                that integrates both of these entities and their respective ID values, as annotated by categories there will be a table called recipe_category
                 with columns recipe_id and category_id pointing to the recipe and category objects in their respective columns.</p>
                 <div class="code-wrapper">       
                        <pre><strong>Many To Many Example</strong><code class="language-java">
        
public class Recipe{
                    //There can be many recipes in different categories
                    @ManyToMany
                    @JoinTable(name = "recipe_category",
                    joinColumns = @JoinColumn(name = "recipe_id"), 
                    inverseJoinColumns = @JoinColumn(name = "category_id"))
                    private Set<Category> categories;
                }
                                    
                public class Category{
                //there can be many catagories of recipes
                @ManyToMany(mappedBy = "categories")
                private Set<Recipe> recipes;
            }
        </code>If you look at the <a href="#recipe-image">Recipe Table</a> you'll notice that there is no <strong>Categories column</strong>, that is because
by using the <strong>@JoinTable</strong> annotation, we create a new table in the database, where it holds values and the relationships
between Categories and Recipe</pre></div>    
<img src="https://i.ibb.co/RpqyMvv/Screen-Shot-2019-04-03-at-9-33-56-PM.png" style="max-width: 300px" alt="" srcset="">
<hr>
<br>
<!----------------- CASCADE EXPLANATION ------------------------------->
<h2>Cascade</h2>  
<hr>
<p>You may have noticed the Cascade, this means that anything done to the 'notes' variable will cascade down into the Notes entity itself, and the respective columns of that entity.
     For example, in this program we do not have a NotesRepository to add the Notes objects to our database, by adding a notes object to the recipe it adds to the database, we also have a method however that sets the recipe to the notes which allows for bidirectional relationship</p>

     <div class="code-wrapper">       
            <pre><strong>Cascade example</strong><code class="language-java">

@Entity
public class Recipe{

    @OneToOne(cascade = CascadeType.ALL)
    private Notes notes;
    
    //setter for Notes
    public void setNotes(Notes notes) {
        if(notes != null){
        this.notes = notes;
        //convenience to set Recipe
        notes.setRecipe(this);
        }
    }

}

public class BootStrap{
    //create notes
    Notes guacNotes = new Notes();
    guacNotes.setRecipeNotes("this is a descripting");
                        
    Recipe testRecipe = new Recipe();
    //setting Notes to our recipe using setter
    testRecipe.setNotes(guacNotes);
}
</code>Our setter adds the notes to the recipe entity, as well as adds the recipe to the notes entity</pre></div>     

        </div> <!-- END OF ENTITY PACKAGE DIV-->

        <div id="documentation-part-overview-package-repository">
                <h2>b. Repository Package</h2>
                <br>
                <p> In order for us to upload our entity data into our database, we need to connect to the database, and be able to communicate in order
                    to pass our objects and data to the database. To do this, we make use of <strong>Spring data JPA</strong> and the <strong>CrudRepository</strong> interface with Spring
                </p>
                <br> 
                <div class="code-wrapper">       
                    <pre><strong>Lets take a look at our Recipe Repository</strong><code class="language-java">
        public interface RecipeRepository extends CrudRepository<Recipe, Long>{
        }                                    
 </code>By using the <a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html" target="_blank">CrudRepository Interface</a> We have access to basic <strong>CRUD Methods</strong> to interact with our database.</pre> </div> 

        </div> <!-- END OF REPOSITORY DIV -->

        <div id="documentation-part-overview-package-service">
            <h2>c. Service Package</h2>
            <br>
            <p> These classes are used to <strong>@Autowired</strong>/Inject a <a href="#documentation-part-overview-package-repository">Repository</a>, and be able to customize/use the CRUD Methods
                provided
            </p>
            <br>
            <div class="code-wrapper">       
                <pre><strong>Recipe Service Interface</strong><code class="language-java">
 //create a Service Interface
public interface RecipeService {
  
    Set<Recipe> getRecipes();
                        
    Recipe findById(Long l); 
    
    void deleteById(Long id);
    
    //used for POST operations/forms
    RecipeCommand saveRecipeCommand(RecipeCommand command);

    //used for POST operations/forms                  
    RecipeCommand findCommandById(Long l);
                        

}                                   
</code>This Interface will have methods that will be used to perform CRUD operations, 
In order to use this interface we must create an <strong>Implementation class for it</strong></pre></div> 
<br>
<div class="code-wrapper">       
        <pre><strong>RecipeServiceImpl.java</strong><code class="language-java">
@Service
public class RecipeServiceImpl implements RecipeService{
                
    private final RecipeRepository recipeRepository;
                    
    //command objects
    private final RecipeCommandToRecipe recipeCommandToRecipe;
    private final RecipeToRecipeCommand recipeToRecipeCommand;
                
    @Autowired
    public RecipeServiceImpl(RecipeRepository recipeRepository, RecipeCommandToRecipe recipeCommandToRecipe, RecipeToRecipeCommand recipeToRecipeCommand) {
                        this.recipeRepository = recipeRepository;
                        this.recipeCommandToRecipe = recipeCommandToRecipe;
                        this.recipeToRecipeCommand = recipeToRecipeCommand;
    }
                    
                    
    @Override
    public Set<Recipe> getRecipes() {
    Set<Recipe> recipeSet = new HashSet<>();
    recipeRepository.findAll().iterator().forEachRemaining(recipeSet::add);
    return recipeSet;
}
                
    @Override
    public Recipe findById(Long l) {
    Optional<Recipe> recipeOptional = recipeRepository.findById(l);
                        
    if(recipeOptional.isPresent()){
    return recipeOptional.get();
    }else{
    //response status exception notFOUND
    throw new NotFoundException("Recipe not found, ID = " + l.toString());
    }
                        
        }
                
    //pass in a command object, and turn it into a Recipe object.
                    @Override
                    @Transactional
                    public RecipeCommand saveRecipeCommand(RecipeCommand command) {
                        Recipe detachedRecipe = recipeCommandToRecipe.convert(command);
                        //save the recipe into the database
                        Recipe savedRecipe = recipeRepository.save(detachedRecipe);
                        //return a recipeCommand POJO(this will be used to view things on webpage)
                        return recipeToRecipeCommand.convert(savedRecipe);
                    }
                
                    //Used to update recipes, returns a recipe command by converting a recipe entity
                    @Override
                    @Transactional
                    public RecipeCommand findCommandById(Long l) {
                       return recipeToRecipeCommand.convert(findById(l));
                    }
                
                    @Override
                    public void deleteById(Long id) {
                        recipeRepository.deleteById(id);
                    }
                
                    
                
                }
                                                 
</code>When using the RecipeService class, Spring will <strong>@Autowired/Depdendency Inject</strong> the RecipeServiceImpl.java, which uses the <strong>RecipeRepository</strong></pre></div> 


        </div> <!------------------END OF SERVICE PACKAGE DIV--------------------------->
    

        
    </div><!-- END OF MAIN DOCUMENTATION DIV-->




 

<script src="prism.js"></script>

</body>
</html>